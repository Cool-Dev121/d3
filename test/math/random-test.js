var vows = require("vows"),
    load = require("../load"),
    assert = require("../assert");

var suite = vows.describe("d3.random");

var STDDEV = 5;
var MEAN = 38;


/**
 * Testing a random number generator is a bit more complicated than testing
 * deterministic code, so we use a different methodology.
 *
 * If the RNG is correct, each test in this suite will pass with probability
 * at least P. The tests have been designed so that P is 98%+. If the tests
 * fail consistently, the RNG is broken. The value of P is given above each
 * test case.
 *
 * More on RNG testing here:
 * http://www.johndcook.com/Beautiful_Testing_ch10.pdf
 *
 * @author Daniel Goldbach
 */
suite.addBatch({
  "random": {
    topic: load("math/random").expression("d3.random"),
    "normal": {
      "topic": function(random) {
        return random.normal(MEAN, STDDEV);
      },

      // Mean of n normals is within µ ± 3σ/√n with P=99.7%.
      "has expected mean" : function(normalRNG) {
        var normals = [];
        for (var i=0 ; i<2500 ; i++) {
          normals.push(normalRNG());
        }
        assert.inDelta(d3_test_math_random_mean(normals), MEAN, 3 * STDDEV/50);
      },

      // Variance of n normals is within σ² ± 3*σ²√(2/(n-1)) with P=99.7%.
      "has expected variance" : function(normalRNG) {
        var normals = [];
        for (var i=0 ; i<2500 ; i++) {
          normals.push(normalRNG());
        }
        var sampleVar = d3_test_math_random_variance(normals);
        var radiusAroundMean = 3 * Math.pow(STDDEV, 2) * Math.sqrt(2 / 2499);
        assert.inDelta(sampleVar, Math.pow(STDDEV, 2), radiusAroundMean);
      },

      "has normal distribution" : KSTest(normalCDF(MEAN, STDDEV))
    },
    "logNormal": {
      "topic": function(random) {
        return random.logNormal(MEAN, STDDEV);
      },
      "has log-normal distribution" : KSTest(logNormalCDF(MEAN, STDDEV))
    },
    "irwinHall": {
      "topic": function(random) {
        return random.irwinHall(10);
      },
      "has Irwin-Hall distribution" : KSTest(irwinHallCDF(10))
    }
  }
});

/**
 * A macro that that takes a RNG and asserts that the values generated by the
 * RNG could be generated by a random variable with cumulative distribution
 * function `cdf'. `n' is the number of sample points to use. Higher n = better
 * evaluation, slower test.
 *
 * Passes with P≈98%.
 */
function KSTest(cdf, n) {
  return function(rng) {
    var n = 1000;
    var values = [];
    for (var i = 0; i < n; i++) {
      values.push(rng());
    }
    values.sort(function(a, b) { return a - b; });

    K_positive = -Infinity;  // Identity of max() function
    for (var i = 0; i < n; i++) {
      var edf_i = i / n;  // Empirical distribution function evaluated at x=values[i]
      K_positive = Math.max(K_positive, edf_i - cdf(values[i]));
    }
    K_positive *= Math.sqrt(n);

    // Derivation of this interval is difficult.
    // @see K-S test in Knuth's AoCP vol.2
    assert.inDelta(K_positive, 0.723255, 0.794145);
  }
}

function normalCDF(mean, stddev) {
  // Logistic approximation to normal CDF around N(mean, stddev).
  return function(x) {
    return 1 / (1 + Math.exp(-0.07056 * Math.pow((x-mean)/stddev, 3) - 1.5976 * (x-mean)/stddev));
  }
}

function logNormalCDF(mean, stddev) {
  var normal = normalCDF(1, 1);
  return function(x) {
    return normal((Math.exp(x) - mean) / stddev);
  }
}

function irwinHallCDF(n) {
  var multiplier = 1 / factorial(n);

  // Precompute binom(n, k), k=0..n for efficiency. (<3 closures)
  var binoms = [];
  for (var k = 0; k <= n; k++) {
    binoms.push(binom(n, k));
  }

  return function(x) {
    var t = 0;
    x *= n;
    for (var k = 0; k < x; k++) {
      t += Math.pow(-1, k % 2) * binoms[k] * Math.pow(x - k, n);
    }
    return multiplier * t;
  }
}

function factorial(n) {
  var t = 1;
  for (var i = 2; i <= n; i++) {
    t *= i;
  }
  return t;
}

function binom(n, k) {
  if (k > n) return undefined;
  return factorial(n) / (factorial(k) * factorial(n - k));
}

function d3_test_math_random_mean(arr) {
  if (arr.length === 0) {
    return 0;
  }

  var mean = 0;
  for (var i = 0; i < arr.length; i++) {
    mean += arr[i];
  }
  return mean / arr.length;
}

/**
 * Sample variance implementation borrowed from science.js.
 */
function d3_test_math_random_variance(x) {
  var n = x.length;
  if (n < 1) return NaN;
  if (n === 1) return 0;
  var mean = d3_test_math_random_mean(x),
      i = -1,
      s = 0;
  while (++i < n) {
    var v = x[i] - mean;
    s += v * v;
  }
  return s / (n - 1);
};
suite.export(module);
